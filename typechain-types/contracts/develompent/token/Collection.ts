/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../../common";

export declare namespace Collection {
  export type InputRoyaltySettingsStruct = {
    investorFee: PromiseOrValue<BigNumberish>;
    creators: PromiseOrValue<string>[];
    creatorsFees: PromiseOrValue<BigNumberish>[];
  };

  export type InputRoyaltySettingsStructOutput = [
    BigNumber,
    string[],
    BigNumber[]
  ] & { investorFee: BigNumber; creators: string[]; creatorsFees: BigNumber[] };

  export type InputPaymentSettingsStruct = {
    paymentToken: PromiseOrValue<string>;
    paymentAmount: PromiseOrValue<BigNumberish>;
    paymentReceivers: PromiseOrValue<string>[];
    receiversShares: PromiseOrValue<BigNumberish>[];
  };

  export type InputPaymentSettingsStructOutput = [
    string,
    BigNumber,
    string[],
    BigNumber[]
  ] & {
    paymentToken: string;
    paymentAmount: BigNumber;
    paymentReceivers: string[];
    receiversShares: BigNumber[];
  };

  export type FeeReceiverStruct = {
    account: PromiseOrValue<string>;
    fee: PromiseOrValue<BigNumberish>;
  };

  export type FeeReceiverStructOutput = [string, BigNumber] & {
    account: string;
    fee: BigNumber;
  };
}

export declare namespace ICollectionData {
  export type CollectionDataStruct = {
    name: PromiseOrValue<string>;
    symbol: PromiseOrValue<string>;
    baseURI: PromiseOrValue<string>;
    whitelist: PromiseOrValue<BytesLike>;
    bookingList: PromiseOrValue<BytesLike>;
    publicMintTokensLimit: PromiseOrValue<BigNumberish>;
    earnings: PromiseOrValue<BigNumberish>;
    mintStage: PromiseOrValue<BigNumberish>;
  };

  export type CollectionDataStructOutput = [
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    number
  ] & {
    name: string;
    symbol: string;
    baseURI: string;
    whitelist: string;
    bookingList: string;
    publicMintTokensLimit: BigNumber;
    earnings: BigNumber;
    mintStage: number;
  };
}

export interface CollectionInterface extends utils.Interface {
  functions: {
    "ADMINS_BOOKING_ADDRESS()": FunctionFragment;
    "BRAND_ADMIN_ROLE()": FunctionFragment;
    "COLLECTION_ADMIN_ROLE()": FunctionFragment;
    "DEFAULT_LIMIT()": FunctionFragment;
    "DENOMINATOR()": FunctionFragment;
    "EARNINGS_LIMIT()": FunctionFragment;
    "LIST_MODERATOR_ROLE()": FunctionFragment;
    "WHITELIST_ADDITION()": FunctionFragment;
    "approve(address,uint256)": FunctionFragment;
    "balanceOf(address)": FunctionFragment;
    "batchMint(uint256[],uint256[],bytes32[][],bytes32[][],(uint96,address[],uint96[])[],(address,uint256,address[],uint96[])[])": FunctionFragment;
    "batchMintTo(address[],uint256[],bytes32[][],(uint96,address[],uint96[])[],(address,uint256,address[],uint96[])[])": FunctionFragment;
    "batchSafeTransferFrom(address[],address[],uint256[])": FunctionFragment;
    "batchTransferFrom(address[],address[],uint256[])": FunctionFragment;
    "bookingList()": FunctionFragment;
    "canMintToken(address,uint256,uint256,bytes32[],bytes32[],bytes32,bytes32,bytes32)": FunctionFragment;
    "canMintWithWhitelist(address,uint256,uint256,bytes32[],bytes32[],bytes32,bytes32,bytes32)": FunctionFragment;
    "earnings()": FunctionFragment;
    "getApproved(uint256)": FunctionFragment;
    "getRoyalySettings(uint256)": FunctionFragment;
    "hasWhitelist(address,uint256,bytes32[])": FunctionFragment;
    "initialize(address,string,address,uint256,(string,string,string,bytes32,bytes32,uint256,uint96,uint8))": FunctionFragment;
    "isApprovedForAll(address,address)": FunctionFragment;
    "isOwner(address)": FunctionFragment;
    "isTokenBookedFrom(address,uint256,bytes32[],bytes32,bytes32,bytes32)": FunctionFragment;
    "isTokenBookedFromAdmin(uint256,bytes32[],bytes32,bytes32,bytes32)": FunctionFragment;
    "isTokenNotBooked(uint256,bytes32[],bytes32,bytes32,bytes32)": FunctionFragment;
    "masterStation()": FunctionFragment;
    "mint(uint256,uint256,bytes32[],bytes32[],(uint96,address[],uint96[]),(address,uint256,address[],uint96[]))": FunctionFragment;
    "mintStage()": FunctionFragment;
    "mintTo(address,uint256,bytes32[],(uint96,address[],uint96[]),(address,uint256,address[],uint96[]))": FunctionFragment;
    "name()": FunctionFragment;
    "ownedByBrand()": FunctionFragment;
    "owner()": FunctionFragment;
    "ownerOf(uint256)": FunctionFragment;
    "publicMintTokensLimit()": FunctionFragment;
    "publicMintsCounter(address)": FunctionFragment;
    "royaltyInfo(uint256,uint256)": FunctionFragment;
    "safeTransferFrom(address,address,uint256)": FunctionFragment;
    "safeTransferFrom(address,address,uint256,bytes)": FunctionFragment;
    "setApprovalForAll(address,bool)": FunctionFragment;
    "supplyLimit()": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "symbol()": FunctionFragment;
    "tokenByIndex(uint256)": FunctionFragment;
    "tokenOfOwnerByIndex(address,uint256)": FunctionFragment;
    "tokenURI(uint256)": FunctionFragment;
    "totalSupply()": FunctionFragment;
    "transferFrom(address,address,uint256)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "updatePublicMintTokensLimit(uint256)": FunctionFragment;
    "updateRoyaltySettings(uint256,address[],uint96[])": FunctionFragment;
    "updateTreesAndMintStage(bytes32,bytes32,uint8)": FunctionFragment;
    "whitelist()": FunctionFragment;
    "withdraw(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "ADMINS_BOOKING_ADDRESS"
      | "BRAND_ADMIN_ROLE"
      | "COLLECTION_ADMIN_ROLE"
      | "DEFAULT_LIMIT"
      | "DENOMINATOR"
      | "EARNINGS_LIMIT"
      | "LIST_MODERATOR_ROLE"
      | "WHITELIST_ADDITION"
      | "approve"
      | "balanceOf"
      | "batchMint"
      | "batchMintTo"
      | "batchSafeTransferFrom"
      | "batchTransferFrom"
      | "bookingList"
      | "canMintToken"
      | "canMintWithWhitelist"
      | "earnings"
      | "getApproved"
      | "getRoyalySettings"
      | "hasWhitelist"
      | "initialize"
      | "isApprovedForAll"
      | "isOwner"
      | "isTokenBookedFrom"
      | "isTokenBookedFromAdmin"
      | "isTokenNotBooked"
      | "masterStation"
      | "mint"
      | "mintStage"
      | "mintTo"
      | "name"
      | "ownedByBrand"
      | "owner"
      | "ownerOf"
      | "publicMintTokensLimit"
      | "publicMintsCounter"
      | "royaltyInfo"
      | "safeTransferFrom(address,address,uint256)"
      | "safeTransferFrom(address,address,uint256,bytes)"
      | "setApprovalForAll"
      | "supplyLimit"
      | "supportsInterface"
      | "symbol"
      | "tokenByIndex"
      | "tokenOfOwnerByIndex"
      | "tokenURI"
      | "totalSupply"
      | "transferFrom"
      | "transferOwnership"
      | "updatePublicMintTokensLimit"
      | "updateRoyaltySettings"
      | "updateTreesAndMintStage"
      | "whitelist"
      | "withdraw"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "ADMINS_BOOKING_ADDRESS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "BRAND_ADMIN_ROLE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "COLLECTION_ADMIN_ROLE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "DEFAULT_LIMIT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "DENOMINATOR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "EARNINGS_LIMIT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "LIST_MODERATOR_ROLE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "WHITELIST_ADDITION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "batchMint",
    values: [
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>[][],
      PromiseOrValue<BytesLike>[][],
      Collection.InputRoyaltySettingsStruct[],
      Collection.InputPaymentSettingsStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchMintTo",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>[][],
      Collection.InputRoyaltySettingsStruct[],
      Collection.InputPaymentSettingsStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchSafeTransferFrom",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchTransferFrom",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "bookingList",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "canMintToken",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "canMintWithWhitelist",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(functionFragment: "earnings", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getApproved",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getRoyalySettings",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "hasWhitelist",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      ICollectionData.CollectionDataStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isApprovedForAll",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isTokenBookedFrom",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isTokenBookedFromAdmin",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isTokenNotBooked",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "masterStation",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "mint",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BytesLike>[],
      Collection.InputRoyaltySettingsStruct,
      Collection.InputPaymentSettingsStruct
    ]
  ): string;
  encodeFunctionData(functionFragment: "mintStage", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "mintTo",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>[],
      Collection.InputRoyaltySettingsStruct,
      Collection.InputPaymentSettingsStruct
    ]
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "ownedByBrand",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "ownerOf",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "publicMintTokensLimit",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "publicMintsCounter",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "royaltyInfo",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "safeTransferFrom(address,address,uint256)",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "safeTransferFrom(address,address,uint256,bytes)",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovalForAll",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "supplyLimit",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "tokenByIndex",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenOfOwnerByIndex",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenURI",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "updatePublicMintTokensLimit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateRoyaltySettings",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTreesAndMintStage",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(functionFragment: "whitelist", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(
    functionFragment: "ADMINS_BOOKING_ADDRESS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "BRAND_ADMIN_ROLE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "COLLECTION_ADMIN_ROLE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "DEFAULT_LIMIT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "DENOMINATOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "EARNINGS_LIMIT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "LIST_MODERATOR_ROLE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "WHITELIST_ADDITION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "batchMint", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "batchMintTo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchSafeTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bookingList",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canMintToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canMintWithWhitelist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "earnings", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getApproved",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRoyalySettings",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "hasWhitelist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isOwner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isTokenBookedFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isTokenBookedFromAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isTokenNotBooked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "masterStation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mintStage", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mintTo", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "ownedByBrand",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "ownerOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "publicMintTokensLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "publicMintsCounter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "royaltyInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeTransferFrom(address,address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeTransferFrom(address,address,uint256,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApprovalForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supplyLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tokenByIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenOfOwnerByIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "tokenURI", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updatePublicMintTokensLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateRoyaltySettings",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTreesAndMintStage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "whitelist", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;

  events: {
    "AdminBookedTokenMinted(address,address,uint256)": EventFragment;
    "Approval(address,address,uint256)": EventFragment;
    "ApprovalForAll(address,address,bool)": EventFragment;
    "BookedTokenMinted(address,address,uint256)": EventFragment;
    "BookingListUpdated(address,bytes32,bytes32)": EventFragment;
    "CreatorsRoyaltyChanged(uint256,address[],uint96[])": EventFragment;
    "MintStageChanged(address,uint8,uint8)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "PaymentDistributed(uint256,uint256,address[],uint96[])": EventFragment;
    "PublicMintTokensLimitUpdated(uint256,uint256)": EventFragment;
    "PublicTokenMinted(address,uint256)": EventFragment;
    "RoyaltySended(uint256,address,uint256)": EventFragment;
    "RoyaltySetted(uint256,address,uint96,address[],uint96[])": EventFragment;
    "Transfer(address,address,uint256)": EventFragment;
    "WhitelistUpdated(address,bytes32,bytes32)": EventFragment;
    "WhitelistedTokenMinted(address,uint256)": EventFragment;
    "Withdrawn(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AdminBookedTokenMinted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ApprovalForAll"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BookedTokenMinted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BookingListUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CreatorsRoyaltyChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MintStageChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PaymentDistributed"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "PublicMintTokensLimitUpdated"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PublicTokenMinted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoyaltySended"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoyaltySetted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WhitelistUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WhitelistedTokenMinted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdrawn"): EventFragment;
}

export interface AdminBookedTokenMintedEventObject {
  sender: string;
  receiver: string;
  tokenId: BigNumber;
}
export type AdminBookedTokenMintedEvent = TypedEvent<
  [string, string, BigNumber],
  AdminBookedTokenMintedEventObject
>;

export type AdminBookedTokenMintedEventFilter =
  TypedEventFilter<AdminBookedTokenMintedEvent>;

export interface ApprovalEventObject {
  owner: string;
  approved: string;
  tokenId: BigNumber;
}
export type ApprovalEvent = TypedEvent<
  [string, string, BigNumber],
  ApprovalEventObject
>;

export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;

export interface ApprovalForAllEventObject {
  owner: string;
  operator: string;
  approved: boolean;
}
export type ApprovalForAllEvent = TypedEvent<
  [string, string, boolean],
  ApprovalForAllEventObject
>;

export type ApprovalForAllEventFilter = TypedEventFilter<ApprovalForAllEvent>;

export interface BookedTokenMintedEventObject {
  sender: string;
  receiver: string;
  tokenId: BigNumber;
}
export type BookedTokenMintedEvent = TypedEvent<
  [string, string, BigNumber],
  BookedTokenMintedEventObject
>;

export type BookedTokenMintedEventFilter =
  TypedEventFilter<BookedTokenMintedEvent>;

export interface BookingListUpdatedEventObject {
  sender: string;
  previousMerkleRoot: string;
  actualMerkleRoot: string;
}
export type BookingListUpdatedEvent = TypedEvent<
  [string, string, string],
  BookingListUpdatedEventObject
>;

export type BookingListUpdatedEventFilter =
  TypedEventFilter<BookingListUpdatedEvent>;

export interface CreatorsRoyaltyChangedEventObject {
  token: BigNumber;
  creators: string[];
  creatorsFees: BigNumber[];
}
export type CreatorsRoyaltyChangedEvent = TypedEvent<
  [BigNumber, string[], BigNumber[]],
  CreatorsRoyaltyChangedEventObject
>;

export type CreatorsRoyaltyChangedEventFilter =
  TypedEventFilter<CreatorsRoyaltyChangedEvent>;

export interface MintStageChangedEventObject {
  sender: string;
  previousMintStage: number;
  actualMintStage: number;
}
export type MintStageChangedEvent = TypedEvent<
  [string, number, number],
  MintStageChangedEventObject
>;

export type MintStageChangedEventFilter =
  TypedEventFilter<MintStageChangedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface PaymentDistributedEventObject {
  token: BigNumber;
  paymentAmount: BigNumber;
  receivers: string[];
  shares: BigNumber[];
}
export type PaymentDistributedEvent = TypedEvent<
  [BigNumber, BigNumber, string[], BigNumber[]],
  PaymentDistributedEventObject
>;

export type PaymentDistributedEventFilter =
  TypedEventFilter<PaymentDistributedEvent>;

export interface PublicMintTokensLimitUpdatedEventObject {
  previousLimit: BigNumber;
  actualLimit: BigNumber;
}
export type PublicMintTokensLimitUpdatedEvent = TypedEvent<
  [BigNumber, BigNumber],
  PublicMintTokensLimitUpdatedEventObject
>;

export type PublicMintTokensLimitUpdatedEventFilter =
  TypedEventFilter<PublicMintTokensLimitUpdatedEvent>;

export interface PublicTokenMintedEventObject {
  receiver: string;
  tokenId: BigNumber;
}
export type PublicTokenMintedEvent = TypedEvent<
  [string, BigNumber],
  PublicTokenMintedEventObject
>;

export type PublicTokenMintedEventFilter =
  TypedEventFilter<PublicTokenMintedEvent>;

export interface RoyaltySendedEventObject {
  token: BigNumber;
  receiver: string;
  amount: BigNumber;
}
export type RoyaltySendedEvent = TypedEvent<
  [BigNumber, string, BigNumber],
  RoyaltySendedEventObject
>;

export type RoyaltySendedEventFilter = TypedEventFilter<RoyaltySendedEvent>;

export interface RoyaltySettedEventObject {
  token: BigNumber;
  investor: string;
  investorFee: BigNumber;
  creators: string[];
  creatorsFees: BigNumber[];
}
export type RoyaltySettedEvent = TypedEvent<
  [BigNumber, string, BigNumber, string[], BigNumber[]],
  RoyaltySettedEventObject
>;

export type RoyaltySettedEventFilter = TypedEventFilter<RoyaltySettedEvent>;

export interface TransferEventObject {
  from: string;
  to: string;
  tokenId: BigNumber;
}
export type TransferEvent = TypedEvent<
  [string, string, BigNumber],
  TransferEventObject
>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export interface WhitelistUpdatedEventObject {
  sender: string;
  previousMerkleRoot: string;
  actualMerkleRoot: string;
}
export type WhitelistUpdatedEvent = TypedEvent<
  [string, string, string],
  WhitelistUpdatedEventObject
>;

export type WhitelistUpdatedEventFilter =
  TypedEventFilter<WhitelistUpdatedEvent>;

export interface WhitelistedTokenMintedEventObject {
  receiver: string;
  tokenId: BigNumber;
}
export type WhitelistedTokenMintedEvent = TypedEvent<
  [string, BigNumber],
  WhitelistedTokenMintedEventObject
>;

export type WhitelistedTokenMintedEventFilter =
  TypedEventFilter<WhitelistedTokenMintedEvent>;

export interface WithdrawnEventObject {
  to: string;
  token: string;
  amount: BigNumber;
}
export type WithdrawnEvent = TypedEvent<
  [string, string, BigNumber],
  WithdrawnEventObject
>;

export type WithdrawnEventFilter = TypedEventFilter<WithdrawnEvent>;

export interface Collection extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: CollectionInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    ADMINS_BOOKING_ADDRESS(overrides?: CallOverrides): Promise<[string]>;

    BRAND_ADMIN_ROLE(overrides?: CallOverrides): Promise<[number]>;

    COLLECTION_ADMIN_ROLE(overrides?: CallOverrides): Promise<[number]>;

    DEFAULT_LIMIT(overrides?: CallOverrides): Promise<[BigNumber]>;

    DENOMINATOR(overrides?: CallOverrides): Promise<[BigNumber]>;

    EARNINGS_LIMIT(overrides?: CallOverrides): Promise<[BigNumber]>;

    LIST_MODERATOR_ROLE(overrides?: CallOverrides): Promise<[number]>;

    WHITELIST_ADDITION(overrides?: CallOverrides): Promise<[string]>;

    approve(
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    balanceOf(
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    batchMint(
      tokensId: PromiseOrValue<BigNumberish>[],
      mintLimits: PromiseOrValue<BigNumberish>[],
      bookingProofs: PromiseOrValue<BytesLike>[][],
      whitelistProofs: PromiseOrValue<BytesLike>[][],
      royaltySettings: Collection.InputRoyaltySettingsStruct[],
      paymentSettings: Collection.InputPaymentSettingsStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    batchMintTo(
      receivers: PromiseOrValue<string>[],
      tokensId: PromiseOrValue<BigNumberish>[],
      bookingProofs: PromiseOrValue<BytesLike>[][],
      royaltySettings: Collection.InputRoyaltySettingsStruct[],
      paymentSettings: Collection.InputPaymentSettingsStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    batchSafeTransferFrom(
      spenders: PromiseOrValue<string>[],
      receivers: PromiseOrValue<string>[],
      tokensId: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    batchTransferFrom(
      spenders: PromiseOrValue<string>[],
      receivers: PromiseOrValue<string>[],
      tokensId: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    bookingList(
      overrides?: CallOverrides
    ): Promise<[string] & { rootHash: string }>;

    canMintToken(
      user: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      mintLimit: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      whitelistProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    canMintWithWhitelist(
      user: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      mintLimit: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      whitelistProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    earnings(overrides?: CallOverrides): Promise<[BigNumber]>;

    getApproved(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getRoyalySettings(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        Collection.FeeReceiverStructOutput,
        Collection.FeeReceiverStructOutput[]
      ] & {
        investor: Collection.FeeReceiverStructOutput;
        creators: Collection.FeeReceiverStructOutput[];
      }
    >;

    hasWhitelist(
      user: PromiseOrValue<string>,
      mintLimit: PromiseOrValue<BigNumberish>,
      whitelistProof: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    initialize(
      _masterStation: PromiseOrValue<string>,
      _brand: PromiseOrValue<string>,
      _creator: PromiseOrValue<string>,
      _supplyLimit: PromiseOrValue<BigNumberish>,
      _data: ICollectionData.CollectionDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isApprovedForAll(
      owner: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isOwner(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isTokenBookedFrom(
      user: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isTokenBookedFromAdmin(
      tokenId: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isTokenNotBooked(
      tokenId: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    masterStation(overrides?: CallOverrides): Promise<[string]>;

    mint(
      tokenId: PromiseOrValue<BigNumberish>,
      mintLimit: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      whitelistProof: PromiseOrValue<BytesLike>[],
      royaltySettings: Collection.InputRoyaltySettingsStruct,
      paymentSettings: Collection.InputPaymentSettingsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    mintStage(overrides?: CallOverrides): Promise<[number]>;

    mintTo(
      receiver: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      royaltySettings: Collection.InputRoyaltySettingsStruct,
      paymentSettings: Collection.InputPaymentSettingsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    name(overrides?: CallOverrides): Promise<[string]>;

    ownedByBrand(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    ownerOf(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    publicMintTokensLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

    publicMintsCounter(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    royaltyInfo(
      _tokenId: PromiseOrValue<BigNumberish>,
      _salePrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string, BigNumber]>;

    "safeTransferFrom(address,address,uint256)"(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "safeTransferFrom(address,address,uint256,bytes)"(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    supplyLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    symbol(overrides?: CallOverrides): Promise<[string]>;

    tokenByIndex(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    tokenOfOwnerByIndex(
      owner: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    tokenURI(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    transferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updatePublicMintTokensLimit(
      _publicMintTokensLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateRoyaltySettings(
      tokenId: PromiseOrValue<BigNumberish>,
      creators: PromiseOrValue<string>[],
      creatorsFees: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateTreesAndMintStage(
      whitelistHash: PromiseOrValue<BytesLike>,
      bookingHash: PromiseOrValue<BytesLike>,
      _mintStage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    whitelist(
      overrides?: CallOverrides
    ): Promise<[string] & { rootHash: string }>;

    withdraw(
      tokenAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  ADMINS_BOOKING_ADDRESS(overrides?: CallOverrides): Promise<string>;

  BRAND_ADMIN_ROLE(overrides?: CallOverrides): Promise<number>;

  COLLECTION_ADMIN_ROLE(overrides?: CallOverrides): Promise<number>;

  DEFAULT_LIMIT(overrides?: CallOverrides): Promise<BigNumber>;

  DENOMINATOR(overrides?: CallOverrides): Promise<BigNumber>;

  EARNINGS_LIMIT(overrides?: CallOverrides): Promise<BigNumber>;

  LIST_MODERATOR_ROLE(overrides?: CallOverrides): Promise<number>;

  WHITELIST_ADDITION(overrides?: CallOverrides): Promise<string>;

  approve(
    to: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  balanceOf(
    owner: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  batchMint(
    tokensId: PromiseOrValue<BigNumberish>[],
    mintLimits: PromiseOrValue<BigNumberish>[],
    bookingProofs: PromiseOrValue<BytesLike>[][],
    whitelistProofs: PromiseOrValue<BytesLike>[][],
    royaltySettings: Collection.InputRoyaltySettingsStruct[],
    paymentSettings: Collection.InputPaymentSettingsStruct[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  batchMintTo(
    receivers: PromiseOrValue<string>[],
    tokensId: PromiseOrValue<BigNumberish>[],
    bookingProofs: PromiseOrValue<BytesLike>[][],
    royaltySettings: Collection.InputRoyaltySettingsStruct[],
    paymentSettings: Collection.InputPaymentSettingsStruct[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  batchSafeTransferFrom(
    spenders: PromiseOrValue<string>[],
    receivers: PromiseOrValue<string>[],
    tokensId: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  batchTransferFrom(
    spenders: PromiseOrValue<string>[],
    receivers: PromiseOrValue<string>[],
    tokensId: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  bookingList(overrides?: CallOverrides): Promise<string>;

  canMintToken(
    user: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    mintLimit: PromiseOrValue<BigNumberish>,
    bookingProof: PromiseOrValue<BytesLike>[],
    whitelistProof: PromiseOrValue<BytesLike>[],
    creatorsHash: PromiseOrValue<BytesLike>,
    paymentHash: PromiseOrValue<BytesLike>,
    receiversHash: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  canMintWithWhitelist(
    user: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    mintLimit: PromiseOrValue<BigNumberish>,
    bookingProof: PromiseOrValue<BytesLike>[],
    whitelistProof: PromiseOrValue<BytesLike>[],
    creatorsHash: PromiseOrValue<BytesLike>,
    paymentHash: PromiseOrValue<BytesLike>,
    receiversHash: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  earnings(overrides?: CallOverrides): Promise<BigNumber>;

  getApproved(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  getRoyalySettings(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [
      Collection.FeeReceiverStructOutput,
      Collection.FeeReceiverStructOutput[]
    ] & {
      investor: Collection.FeeReceiverStructOutput;
      creators: Collection.FeeReceiverStructOutput[];
    }
  >;

  hasWhitelist(
    user: PromiseOrValue<string>,
    mintLimit: PromiseOrValue<BigNumberish>,
    whitelistProof: PromiseOrValue<BytesLike>[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  initialize(
    _masterStation: PromiseOrValue<string>,
    _brand: PromiseOrValue<string>,
    _creator: PromiseOrValue<string>,
    _supplyLimit: PromiseOrValue<BigNumberish>,
    _data: ICollectionData.CollectionDataStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isApprovedForAll(
    owner: PromiseOrValue<string>,
    operator: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isOwner(
    addr: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isTokenBookedFrom(
    user: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    bookingProof: PromiseOrValue<BytesLike>[],
    creatorsHash: PromiseOrValue<BytesLike>,
    paymentHash: PromiseOrValue<BytesLike>,
    receiversHash: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isTokenBookedFromAdmin(
    tokenId: PromiseOrValue<BigNumberish>,
    bookingProof: PromiseOrValue<BytesLike>[],
    creatorsHash: PromiseOrValue<BytesLike>,
    paymentHash: PromiseOrValue<BytesLike>,
    receiversHash: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isTokenNotBooked(
    tokenId: PromiseOrValue<BigNumberish>,
    bookingProof: PromiseOrValue<BytesLike>[],
    creatorsHash: PromiseOrValue<BytesLike>,
    paymentHash: PromiseOrValue<BytesLike>,
    receiversHash: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  masterStation(overrides?: CallOverrides): Promise<string>;

  mint(
    tokenId: PromiseOrValue<BigNumberish>,
    mintLimit: PromiseOrValue<BigNumberish>,
    bookingProof: PromiseOrValue<BytesLike>[],
    whitelistProof: PromiseOrValue<BytesLike>[],
    royaltySettings: Collection.InputRoyaltySettingsStruct,
    paymentSettings: Collection.InputPaymentSettingsStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  mintStage(overrides?: CallOverrides): Promise<number>;

  mintTo(
    receiver: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    bookingProof: PromiseOrValue<BytesLike>[],
    royaltySettings: Collection.InputRoyaltySettingsStruct,
    paymentSettings: Collection.InputPaymentSettingsStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  name(overrides?: CallOverrides): Promise<string>;

  ownedByBrand(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  ownerOf(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  publicMintTokensLimit(overrides?: CallOverrides): Promise<BigNumber>;

  publicMintsCounter(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  royaltyInfo(
    _tokenId: PromiseOrValue<BigNumberish>,
    _salePrice: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[string, BigNumber]>;

  "safeTransferFrom(address,address,uint256)"(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "safeTransferFrom(address,address,uint256,bytes)"(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setApprovalForAll(
    operator: PromiseOrValue<string>,
    approved: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  supplyLimit(overrides?: CallOverrides): Promise<BigNumber>;

  supportsInterface(
    interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  symbol(overrides?: CallOverrides): Promise<string>;

  tokenByIndex(
    index: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  tokenOfOwnerByIndex(
    owner: PromiseOrValue<string>,
    index: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  tokenURI(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  transferFrom(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updatePublicMintTokensLimit(
    _publicMintTokensLimit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateRoyaltySettings(
    tokenId: PromiseOrValue<BigNumberish>,
    creators: PromiseOrValue<string>[],
    creatorsFees: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateTreesAndMintStage(
    whitelistHash: PromiseOrValue<BytesLike>,
    bookingHash: PromiseOrValue<BytesLike>,
    _mintStage: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  whitelist(overrides?: CallOverrides): Promise<string>;

  withdraw(
    tokenAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    ADMINS_BOOKING_ADDRESS(overrides?: CallOverrides): Promise<string>;

    BRAND_ADMIN_ROLE(overrides?: CallOverrides): Promise<number>;

    COLLECTION_ADMIN_ROLE(overrides?: CallOverrides): Promise<number>;

    DEFAULT_LIMIT(overrides?: CallOverrides): Promise<BigNumber>;

    DENOMINATOR(overrides?: CallOverrides): Promise<BigNumber>;

    EARNINGS_LIMIT(overrides?: CallOverrides): Promise<BigNumber>;

    LIST_MODERATOR_ROLE(overrides?: CallOverrides): Promise<number>;

    WHITELIST_ADDITION(overrides?: CallOverrides): Promise<string>;

    approve(
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    balanceOf(
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    batchMint(
      tokensId: PromiseOrValue<BigNumberish>[],
      mintLimits: PromiseOrValue<BigNumberish>[],
      bookingProofs: PromiseOrValue<BytesLike>[][],
      whitelistProofs: PromiseOrValue<BytesLike>[][],
      royaltySettings: Collection.InputRoyaltySettingsStruct[],
      paymentSettings: Collection.InputPaymentSettingsStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchMintTo(
      receivers: PromiseOrValue<string>[],
      tokensId: PromiseOrValue<BigNumberish>[],
      bookingProofs: PromiseOrValue<BytesLike>[][],
      royaltySettings: Collection.InputRoyaltySettingsStruct[],
      paymentSettings: Collection.InputPaymentSettingsStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchSafeTransferFrom(
      spenders: PromiseOrValue<string>[],
      receivers: PromiseOrValue<string>[],
      tokensId: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchTransferFrom(
      spenders: PromiseOrValue<string>[],
      receivers: PromiseOrValue<string>[],
      tokensId: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    bookingList(overrides?: CallOverrides): Promise<string>;

    canMintToken(
      user: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      mintLimit: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      whitelistProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    canMintWithWhitelist(
      user: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      mintLimit: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      whitelistProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    earnings(overrides?: CallOverrides): Promise<BigNumber>;

    getApproved(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getRoyalySettings(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        Collection.FeeReceiverStructOutput,
        Collection.FeeReceiverStructOutput[]
      ] & {
        investor: Collection.FeeReceiverStructOutput;
        creators: Collection.FeeReceiverStructOutput[];
      }
    >;

    hasWhitelist(
      user: PromiseOrValue<string>,
      mintLimit: PromiseOrValue<BigNumberish>,
      whitelistProof: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    initialize(
      _masterStation: PromiseOrValue<string>,
      _brand: PromiseOrValue<string>,
      _creator: PromiseOrValue<string>,
      _supplyLimit: PromiseOrValue<BigNumberish>,
      _data: ICollectionData.CollectionDataStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    isApprovedForAll(
      owner: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isOwner(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isTokenBookedFrom(
      user: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isTokenBookedFromAdmin(
      tokenId: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isTokenNotBooked(
      tokenId: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    masterStation(overrides?: CallOverrides): Promise<string>;

    mint(
      tokenId: PromiseOrValue<BigNumberish>,
      mintLimit: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      whitelistProof: PromiseOrValue<BytesLike>[],
      royaltySettings: Collection.InputRoyaltySettingsStruct,
      paymentSettings: Collection.InputPaymentSettingsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    mintStage(overrides?: CallOverrides): Promise<number>;

    mintTo(
      receiver: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      royaltySettings: Collection.InputRoyaltySettingsStruct,
      paymentSettings: Collection.InputPaymentSettingsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    name(overrides?: CallOverrides): Promise<string>;

    ownedByBrand(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    ownerOf(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    publicMintTokensLimit(overrides?: CallOverrides): Promise<BigNumber>;

    publicMintsCounter(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    royaltyInfo(
      _tokenId: PromiseOrValue<BigNumberish>,
      _salePrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string, BigNumber]>;

    "safeTransferFrom(address,address,uint256)"(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    "safeTransferFrom(address,address,uint256,bytes)"(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    supplyLimit(overrides?: CallOverrides): Promise<BigNumber>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    symbol(overrides?: CallOverrides): Promise<string>;

    tokenByIndex(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenOfOwnerByIndex(
      owner: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenURI(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    updatePublicMintTokensLimit(
      _publicMintTokensLimit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateRoyaltySettings(
      tokenId: PromiseOrValue<BigNumberish>,
      creators: PromiseOrValue<string>[],
      creatorsFees: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    updateTreesAndMintStage(
      whitelistHash: PromiseOrValue<BytesLike>,
      bookingHash: PromiseOrValue<BytesLike>,
      _mintStage: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    whitelist(overrides?: CallOverrides): Promise<string>;

    withdraw(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AdminBookedTokenMinted(address,address,uint256)"(
      sender?: PromiseOrValue<string> | null,
      receiver?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): AdminBookedTokenMintedEventFilter;
    AdminBookedTokenMinted(
      sender?: PromiseOrValue<string> | null,
      receiver?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): AdminBookedTokenMintedEventFilter;

    "Approval(address,address,uint256)"(
      owner?: PromiseOrValue<string> | null,
      approved?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): ApprovalEventFilter;
    Approval(
      owner?: PromiseOrValue<string> | null,
      approved?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): ApprovalEventFilter;

    "ApprovalForAll(address,address,bool)"(
      owner?: PromiseOrValue<string> | null,
      operator?: PromiseOrValue<string> | null,
      approved?: null
    ): ApprovalForAllEventFilter;
    ApprovalForAll(
      owner?: PromiseOrValue<string> | null,
      operator?: PromiseOrValue<string> | null,
      approved?: null
    ): ApprovalForAllEventFilter;

    "BookedTokenMinted(address,address,uint256)"(
      sender?: PromiseOrValue<string> | null,
      receiver?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): BookedTokenMintedEventFilter;
    BookedTokenMinted(
      sender?: PromiseOrValue<string> | null,
      receiver?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): BookedTokenMintedEventFilter;

    "BookingListUpdated(address,bytes32,bytes32)"(
      sender?: PromiseOrValue<string> | null,
      previousMerkleRoot?: PromiseOrValue<BytesLike> | null,
      actualMerkleRoot?: PromiseOrValue<BytesLike> | null
    ): BookingListUpdatedEventFilter;
    BookingListUpdated(
      sender?: PromiseOrValue<string> | null,
      previousMerkleRoot?: PromiseOrValue<BytesLike> | null,
      actualMerkleRoot?: PromiseOrValue<BytesLike> | null
    ): BookingListUpdatedEventFilter;

    "CreatorsRoyaltyChanged(uint256,address[],uint96[])"(
      token?: PromiseOrValue<BigNumberish> | null,
      creators?: null,
      creatorsFees?: null
    ): CreatorsRoyaltyChangedEventFilter;
    CreatorsRoyaltyChanged(
      token?: PromiseOrValue<BigNumberish> | null,
      creators?: null,
      creatorsFees?: null
    ): CreatorsRoyaltyChangedEventFilter;

    "MintStageChanged(address,uint8,uint8)"(
      sender?: PromiseOrValue<string> | null,
      previousMintStage?: PromiseOrValue<BigNumberish> | null,
      actualMintStage?: PromiseOrValue<BigNumberish> | null
    ): MintStageChangedEventFilter;
    MintStageChanged(
      sender?: PromiseOrValue<string> | null,
      previousMintStage?: PromiseOrValue<BigNumberish> | null,
      actualMintStage?: PromiseOrValue<BigNumberish> | null
    ): MintStageChangedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "PaymentDistributed(uint256,uint256,address[],uint96[])"(
      token?: PromiseOrValue<BigNumberish> | null,
      paymentAmount?: null,
      receivers?: null,
      shares?: null
    ): PaymentDistributedEventFilter;
    PaymentDistributed(
      token?: PromiseOrValue<BigNumberish> | null,
      paymentAmount?: null,
      receivers?: null,
      shares?: null
    ): PaymentDistributedEventFilter;

    "PublicMintTokensLimitUpdated(uint256,uint256)"(
      previousLimit?: PromiseOrValue<BigNumberish> | null,
      actualLimit?: PromiseOrValue<BigNumberish> | null
    ): PublicMintTokensLimitUpdatedEventFilter;
    PublicMintTokensLimitUpdated(
      previousLimit?: PromiseOrValue<BigNumberish> | null,
      actualLimit?: PromiseOrValue<BigNumberish> | null
    ): PublicMintTokensLimitUpdatedEventFilter;

    "PublicTokenMinted(address,uint256)"(
      receiver?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): PublicTokenMintedEventFilter;
    PublicTokenMinted(
      receiver?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): PublicTokenMintedEventFilter;

    "RoyaltySended(uint256,address,uint256)"(
      token?: PromiseOrValue<BigNumberish> | null,
      receiver?: PromiseOrValue<string> | null,
      amount?: null
    ): RoyaltySendedEventFilter;
    RoyaltySended(
      token?: PromiseOrValue<BigNumberish> | null,
      receiver?: PromiseOrValue<string> | null,
      amount?: null
    ): RoyaltySendedEventFilter;

    "RoyaltySetted(uint256,address,uint96,address[],uint96[])"(
      token?: PromiseOrValue<BigNumberish> | null,
      investor?: PromiseOrValue<string> | null,
      investorFee?: null,
      creators?: null,
      creatorsFees?: null
    ): RoyaltySettedEventFilter;
    RoyaltySetted(
      token?: PromiseOrValue<BigNumberish> | null,
      investor?: PromiseOrValue<string> | null,
      investorFee?: null,
      creators?: null,
      creatorsFees?: null
    ): RoyaltySettedEventFilter;

    "Transfer(address,address,uint256)"(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): TransferEventFilter;
    Transfer(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): TransferEventFilter;

    "WhitelistUpdated(address,bytes32,bytes32)"(
      sender?: PromiseOrValue<string> | null,
      previousMerkleRoot?: PromiseOrValue<BytesLike> | null,
      actualMerkleRoot?: PromiseOrValue<BytesLike> | null
    ): WhitelistUpdatedEventFilter;
    WhitelistUpdated(
      sender?: PromiseOrValue<string> | null,
      previousMerkleRoot?: PromiseOrValue<BytesLike> | null,
      actualMerkleRoot?: PromiseOrValue<BytesLike> | null
    ): WhitelistUpdatedEventFilter;

    "WhitelistedTokenMinted(address,uint256)"(
      receiver?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): WhitelistedTokenMintedEventFilter;
    WhitelistedTokenMinted(
      receiver?: PromiseOrValue<string> | null,
      tokenId?: PromiseOrValue<BigNumberish> | null
    ): WhitelistedTokenMintedEventFilter;

    "Withdrawn(address,address,uint256)"(
      to?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): WithdrawnEventFilter;
    Withdrawn(
      to?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): WithdrawnEventFilter;
  };

  estimateGas: {
    ADMINS_BOOKING_ADDRESS(overrides?: CallOverrides): Promise<BigNumber>;

    BRAND_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    COLLECTION_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    DEFAULT_LIMIT(overrides?: CallOverrides): Promise<BigNumber>;

    DENOMINATOR(overrides?: CallOverrides): Promise<BigNumber>;

    EARNINGS_LIMIT(overrides?: CallOverrides): Promise<BigNumber>;

    LIST_MODERATOR_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    WHITELIST_ADDITION(overrides?: CallOverrides): Promise<BigNumber>;

    approve(
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    balanceOf(
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    batchMint(
      tokensId: PromiseOrValue<BigNumberish>[],
      mintLimits: PromiseOrValue<BigNumberish>[],
      bookingProofs: PromiseOrValue<BytesLike>[][],
      whitelistProofs: PromiseOrValue<BytesLike>[][],
      royaltySettings: Collection.InputRoyaltySettingsStruct[],
      paymentSettings: Collection.InputPaymentSettingsStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    batchMintTo(
      receivers: PromiseOrValue<string>[],
      tokensId: PromiseOrValue<BigNumberish>[],
      bookingProofs: PromiseOrValue<BytesLike>[][],
      royaltySettings: Collection.InputRoyaltySettingsStruct[],
      paymentSettings: Collection.InputPaymentSettingsStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    batchSafeTransferFrom(
      spenders: PromiseOrValue<string>[],
      receivers: PromiseOrValue<string>[],
      tokensId: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    batchTransferFrom(
      spenders: PromiseOrValue<string>[],
      receivers: PromiseOrValue<string>[],
      tokensId: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    bookingList(overrides?: CallOverrides): Promise<BigNumber>;

    canMintToken(
      user: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      mintLimit: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      whitelistProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    canMintWithWhitelist(
      user: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      mintLimit: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      whitelistProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    earnings(overrides?: CallOverrides): Promise<BigNumber>;

    getApproved(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRoyalySettings(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hasWhitelist(
      user: PromiseOrValue<string>,
      mintLimit: PromiseOrValue<BigNumberish>,
      whitelistProof: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      _masterStation: PromiseOrValue<string>,
      _brand: PromiseOrValue<string>,
      _creator: PromiseOrValue<string>,
      _supplyLimit: PromiseOrValue<BigNumberish>,
      _data: ICollectionData.CollectionDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isApprovedForAll(
      owner: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isOwner(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isTokenBookedFrom(
      user: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isTokenBookedFromAdmin(
      tokenId: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isTokenNotBooked(
      tokenId: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    masterStation(overrides?: CallOverrides): Promise<BigNumber>;

    mint(
      tokenId: PromiseOrValue<BigNumberish>,
      mintLimit: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      whitelistProof: PromiseOrValue<BytesLike>[],
      royaltySettings: Collection.InputRoyaltySettingsStruct,
      paymentSettings: Collection.InputPaymentSettingsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    mintStage(overrides?: CallOverrides): Promise<BigNumber>;

    mintTo(
      receiver: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      royaltySettings: Collection.InputRoyaltySettingsStruct,
      paymentSettings: Collection.InputPaymentSettingsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    ownedByBrand(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    ownerOf(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    publicMintTokensLimit(overrides?: CallOverrides): Promise<BigNumber>;

    publicMintsCounter(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    royaltyInfo(
      _tokenId: PromiseOrValue<BigNumberish>,
      _salePrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "safeTransferFrom(address,address,uint256)"(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "safeTransferFrom(address,address,uint256,bytes)"(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    supplyLimit(overrides?: CallOverrides): Promise<BigNumber>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    tokenByIndex(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenOfOwnerByIndex(
      owner: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenURI(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updatePublicMintTokensLimit(
      _publicMintTokensLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateRoyaltySettings(
      tokenId: PromiseOrValue<BigNumberish>,
      creators: PromiseOrValue<string>[],
      creatorsFees: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateTreesAndMintStage(
      whitelistHash: PromiseOrValue<BytesLike>,
      bookingHash: PromiseOrValue<BytesLike>,
      _mintStage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    whitelist(overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      tokenAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    ADMINS_BOOKING_ADDRESS(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    BRAND_ADMIN_ROLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    COLLECTION_ADMIN_ROLE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    DEFAULT_LIMIT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    DENOMINATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    EARNINGS_LIMIT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    LIST_MODERATOR_ROLE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    WHITELIST_ADDITION(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    approve(
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    balanceOf(
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    batchMint(
      tokensId: PromiseOrValue<BigNumberish>[],
      mintLimits: PromiseOrValue<BigNumberish>[],
      bookingProofs: PromiseOrValue<BytesLike>[][],
      whitelistProofs: PromiseOrValue<BytesLike>[][],
      royaltySettings: Collection.InputRoyaltySettingsStruct[],
      paymentSettings: Collection.InputPaymentSettingsStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    batchMintTo(
      receivers: PromiseOrValue<string>[],
      tokensId: PromiseOrValue<BigNumberish>[],
      bookingProofs: PromiseOrValue<BytesLike>[][],
      royaltySettings: Collection.InputRoyaltySettingsStruct[],
      paymentSettings: Collection.InputPaymentSettingsStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    batchSafeTransferFrom(
      spenders: PromiseOrValue<string>[],
      receivers: PromiseOrValue<string>[],
      tokensId: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    batchTransferFrom(
      spenders: PromiseOrValue<string>[],
      receivers: PromiseOrValue<string>[],
      tokensId: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    bookingList(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    canMintToken(
      user: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      mintLimit: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      whitelistProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    canMintWithWhitelist(
      user: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      mintLimit: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      whitelistProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    earnings(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getApproved(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRoyalySettings(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hasWhitelist(
      user: PromiseOrValue<string>,
      mintLimit: PromiseOrValue<BigNumberish>,
      whitelistProof: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      _masterStation: PromiseOrValue<string>,
      _brand: PromiseOrValue<string>,
      _creator: PromiseOrValue<string>,
      _supplyLimit: PromiseOrValue<BigNumberish>,
      _data: ICollectionData.CollectionDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isApprovedForAll(
      owner: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isOwner(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isTokenBookedFrom(
      user: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isTokenBookedFromAdmin(
      tokenId: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isTokenNotBooked(
      tokenId: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      creatorsHash: PromiseOrValue<BytesLike>,
      paymentHash: PromiseOrValue<BytesLike>,
      receiversHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    masterStation(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    mint(
      tokenId: PromiseOrValue<BigNumberish>,
      mintLimit: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      whitelistProof: PromiseOrValue<BytesLike>[],
      royaltySettings: Collection.InputRoyaltySettingsStruct,
      paymentSettings: Collection.InputPaymentSettingsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    mintStage(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    mintTo(
      receiver: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      bookingProof: PromiseOrValue<BytesLike>[],
      royaltySettings: Collection.InputRoyaltySettingsStruct,
      paymentSettings: Collection.InputPaymentSettingsStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ownedByBrand(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ownerOf(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    publicMintTokensLimit(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    publicMintsCounter(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    royaltyInfo(
      _tokenId: PromiseOrValue<BigNumberish>,
      _salePrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "safeTransferFrom(address,address,uint256)"(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "safeTransferFrom(address,address,uint256,bytes)"(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    supplyLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenByIndex(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenOfOwnerByIndex(
      owner: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenURI(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updatePublicMintTokensLimit(
      _publicMintTokensLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateRoyaltySettings(
      tokenId: PromiseOrValue<BigNumberish>,
      creators: PromiseOrValue<string>[],
      creatorsFees: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateTreesAndMintStage(
      whitelistHash: PromiseOrValue<BytesLike>,
      bookingHash: PromiseOrValue<BytesLike>,
      _mintStage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    whitelist(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdraw(
      tokenAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
